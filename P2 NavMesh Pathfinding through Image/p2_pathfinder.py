import mathfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    boxPath = []    path = []    boxes = {}    currentBox = None    sourceBox = None    destBox = None    dist = {}    forward_prev = {}    backward_prev = {}    found_destBox = False    found_sourceBox = False    possible = False    for el in mesh['boxes']:        if el[0] < source_point[0] and el[1] > source_point[0] and el[2] < source_point[1] and el[3] > source_point[1]:            boxes[el] = el            currentBox = el            sourceBox = el            found_sourceBox = True        if el[0] < destination_point[0] and el[1] > destination_point[0] and el[2] < destination_point[1] and el[3] > destination_point[1]:            destBox = el            found_destBox = True        if(found_sourceBox and found_destBox):            break    # print("START %s" % str(currentBox))    # print("END %s" % str(destBox))    if(currentBox is None):        print("Invalid Starting Point!")        return (path, boxes.keys())    if(destBox is None):        print("Invalid End Point!")        return (path,boxes.keys())    dist[currentBox] = 0    dist[destBox] = 0    queue = [(dist[sourceBox], sourceBox, destination_point)]    heappush(queue, (dist[destBox], destBox, source_point))    forward_prev[sourceBox] = None    backward_prev[destBox] = None    if (currentBox is destBox):        print("check")        return ([(source_point, destination_point)], boxes.keys())    while(queue):        currentCost, currentBox, goal = heappop(queue)        boxes[currentBox] = currentBox        # print("CURRENT BOX %s" % str(currentBox))        for eachAdjBox in mesh['adj'][currentBox]:            shortest = math.hypot(goal[0] - find_waypoint(goal, eachAdjBox)[0], goal[1] - find_waypoint(goal,eachAdjBox)[1])            shortest = dist[currentBox] + shortest            if(goal is destination_point): # A -> Z                if(eachAdjBox not in forward_prev or shortest < dist[eachAdjBox]):                    dist[eachAdjBox] = shortest                    greedy = shortest + heuristic(goal, find_waypoint(goal, eachAdjBox))                    forward_prev[eachAdjBox] = currentBox                    heappush(queue, (greedy, eachAdjBox, goal))                if(eachAdjBox in backward_prev):                    boxes[eachAdjBox] = eachAdjBox                    backward_prev[currentBox] = eachAdjBox                    forward_prev[eachAdjBox] = currentBox                    possible = True            else: # Z -> A                if(eachAdjBox not in backward_prev or shortest < dist[eachAdjBox]):                    dist[eachAdjBox] = shortest                    greedy = shortest + heuristic(goal, find_waypoint(goal, eachAdjBox))                    backward_prev[eachAdjBox] = currentBox                    heappush(queue, (greedy, eachAdjBox, goal))                if(eachAdjBox in forward_prev):                    boxes[eachAdjBox] = eachAdjBox                    backward_prev[eachAdjBox] = currentBox                    forward_prev[currentBox] = eachAdjBox                    possible = True            if(possible):                break        if(possible):            break    switchBox = currentBox    if(possible):        while currentBox is not sourceBox:            # print("A")            boxPath.append(currentBox)            if(currentBox is destBox):  # reached the end                boxPath.reverse()  # instead of O -> Z, we want Z -> O then we start appending N -> A                currentBox = forward_prev[switchBox]                while currentBox is not sourceBox:                    # print("B")                    boxPath.append(currentBox)                    currentBox = forward_prev[currentBox]            else:                currentBox = backward_prev[currentBox]        if(len(boxPath) is 0):  # nothing was inserted in box path because the source and dest boxes are adjacent to each other            # print("BOX LENGTH = 0")            boxPath.append(sourceBox)            boxPath.append(destBox)            if(source_point[0] > destination_point[0] and source_point[1] > destination_point[1]):                boxPath.reverse()        boxPath.reverse() # reverse Z -> A to A -> Z        for el in boxPath:            path.append([source_point, find_waypoint(source_point, el)])            source_point = find_waypoint(source_point, el)        path.append([source_point, destination_point])    else:        print("No Possible Paths")    return path, boxes.keys()def find_waypoint(source, box):    source_x = source[0]    source_y = source[1]    box_x1 = box[0]    box_x2 = box[1]    box_y1 = box[2]    box_y2 = box[3]    x = min(box_x2, max(box_x1, source_x))    y = min(box_y2, max(box_y1, source_y))    return (x, y)def heuristic(a, b):    (x1, y1) = a    (x2, y2) = b    return abs(x1 - x2) + abs(y1 - y2)